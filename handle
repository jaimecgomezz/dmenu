#!/usr/bin/env sh

##############################
# @jaimecgomezz
# 
# This script handles all the
# patching related to this
# dmenu distribution
##############################

set -e

handle_std="0"
handler="patch -p1"
applied_file="applied"

patch_applied() {
  echo "[!] ( $1 ) has already been applied, remove the patch name from the file '$applied_file' if mistaken" ;
  exit 1
}
patch_unapplied() {
  echo "[!] ( $1 ) hasn't been applied yet, add the patch to the file '$applied_file' if mistaken" ;
  exit 1
}
contains() {
  str="$1"
  substr="$2"
  if test "${str#*$substr}" != "$str"; then return 0; fi
  return 1
}
check_dependency() {
  if ! ( command -v "$1" ) > /dev/null ;then
    missing_dependency "$1"
    exit 1
  fi
}
redirect_output() { eval "$@ > /dev/null 2>&1" ; }
print_usage() { cat handle-usage ; exit 1 ; }
missing_dependency() { echo "[!] ( $1 ) missing, please install" ; }


# DEPENDENCIES-CHECK
check_dependency "patch"

# HANDLE-SYNTAX
[ "$#" -lt 2 ] && print_usage

# HANDLE-ARGUMENTS
action="$1"; patch="$2"; shift; shift
contains "$@" "-d" && handle_std="1"
if [ "$action" = "depatch" ]; then options="-R"; fi

patches="$( ls patches/*patch | sed -E 's/(^.*\/)(.*)(\..*)/\2/g' )"
if ! echo "$patches" | grep -q "$patch"; then print_usage; fi

if cat "$applied_file" | grep -q "$patch"; then
  [ "$action" = "depatch" ] || patch_applied "$patch"
else
  [ "$action" = "patch" ] || patch_unapplied "$patch"
fi

apply_patch="$handler $options < patches/${patch}.patch"
build_dmenu="sudo make install clean"

[ "$handle_std" = "0" ] && redirect_output "$apply_patch" || eval "$apply_patch"
[ "$handle_std" = "0" ] && redirect_output "$build_dmenu" || eval "$build_dmenu"

[ "$action" = "patch" ] || sed -i "/^${patch}$/d" "$applied_file"
[ "$action" = "depatch" ] || echo "$patch" >> "$applied_file"

